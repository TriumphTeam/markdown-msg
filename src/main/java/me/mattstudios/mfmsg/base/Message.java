package me.mattstudios.mfmsg.base;

import me.mattstudios.mfmsg.base.internal.ActionLexer;
import me.mattstudios.mfmsg.base.internal.MarkdownVisitor;
import me.mattstudios.mfmsg.base.internal.extension.ObfuscatedExtension;
import me.mattstudios.mfmsg.base.internal.extension.UnderlineExtension;
import me.mattstudios.mfmsg.base.internal.token.ActionToken;
import me.mattstudios.mfmsg.base.internal.token.TextToken;
import me.mattstudios.mfmsg.base.internal.token.Token;
import net.md_5.bungee.api.chat.BaseComponent;
import net.md_5.bungee.api.chat.ClickEvent;
import net.md_5.bungee.api.chat.ComponentBuilder;
import net.md_5.bungee.api.chat.HoverEvent;
import net.md_5.bungee.api.chat.TextComponent;
import org.commonmark.ext.gfm.strikethrough.StrikethroughExtension;
import org.commonmark.parser.Parser;
import org.jetbrains.annotations.NotNull;

import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public final class Message {

    // Pattern for splitting actions with "|"
    private static final Pattern SPLIT_PATTERN = Pattern.compile("(?<!\\\\)\\|");
    // Pattern for the action type and text
    private static final Pattern ACTION_PATTERN = Pattern.compile("^(?<type>\\w+):(?<text>.*)");
    // Commonmark's parser with Strike and Underline extensions
    private static final Parser PARSER = Parser.builder().extensions(Arrays.asList(StrikethroughExtension.create(), UnderlineExtension.create(), ObfuscatedExtension.create())).build();

    // Markdown visitor, which will parse the markdown nodes
    private static final MarkdownVisitor MARKDOWN_VISITOR = new MarkdownVisitor();

    // List of all the generated tokens
    @NotNull
    private final List<Token> tokens;
    // Main component builder
    @NotNull
    private final ComponentBuilder finalBuilder = new ComponentBuilder();

    /**
     * Main constructor that takes in the tokens generated by the lexer
     *
     * @param tokens {@link List} of {@link Token}
     */
    private Message(@NotNull final List<Token> tokens) {
        this.tokens = tokens;
        parseTokens();
    }

    /**
     * Parses the current {@link String} message
     *
     * @param message Markdown format {@link String} message
     * @return A new {@link Message} object
     */
    @NotNull
    public static Message parseTokens(@NotNull final String message) {
        return new Message(ActionLexer.tokenize(message));
    }

    /**
     * Method to parse all the tokens
     */
    private void parseTokens() {
        for (int i = 0; i < tokens.size(); i++) {
            final Token token = tokens.get(i);
            // Checks whether or not the token is an action
            if (token instanceof ActionToken) {
                parseAction((ActionToken) token);
                if (i < tokens.size() - 1) appendSpace();
                continue;
            }

            // Trims and checks if the text is empty
            final String tokenText = ((TextToken) token).getText().trim();
            if (tokenText.isEmpty()) continue;
            // Parses a normal text instead
            MARKDOWN_VISITOR.parse(PARSER.parse(tokenText));
            finalBuilder.append(MARKDOWN_VISITOR.build(), ComponentBuilder.FormatRetention.NONE);
            if (i < tokens.size() - 1) appendSpace();
        }
    }

    /**
     * Appends a space after each token, only required because {@link MarkdownVisitor} will trim the spaces
     */
    private void appendSpace() {
        finalBuilder.append(TextComponent.fromLegacyText(" "), ComponentBuilder.FormatRetention.NONE);
    }

    /**
     * Handles the action parsing
     *
     * @param token The current {@link ActionToken} to parse
     */
    private void parseAction(@NotNull final ActionToken token) {
        HoverEvent hoverEvent = null;
        ClickEvent clickEvent = null;

        // Splits the token message on "|" to separate it's types
        for (final String action : SPLIT_PATTERN.split(token.getActions())) {
            final Matcher matcher = ACTION_PATTERN.matcher(action.trim());

            // If nothing is matched continue
            if (!matcher.find()) continue;

            final String actionText = matcher.group("text").trim();

            // Checks for which action type it is
            switch (matcher.group("type").toLowerCase()) {
                case "hover":
                    // Parses the action text
                    MARKDOWN_VISITOR.parse(PARSER.parse(actionText));
                    hoverEvent = new HoverEvent(HoverEvent.Action.SHOW_TEXT, MARKDOWN_VISITOR.build());
                    break;

                case "command":
                    clickEvent = new ClickEvent(ClickEvent.Action.RUN_COMMAND, actionText);
                    break;

                case "suggest":
                    clickEvent = new ClickEvent(ClickEvent.Action.SUGGEST_COMMAND, actionText);
                    break;

                case "clipboard":
                    clickEvent = new ClickEvent(ClickEvent.Action.COPY_TO_CLIPBOARD, actionText);
                    break;

                case "url":
                    clickEvent = new ClickEvent(ClickEvent.Action.OPEN_URL, actionText);
                    break;
            }
        }

        // Adds the click and hover events
        MARKDOWN_VISITOR.setClickEvent(clickEvent);
        MARKDOWN_VISITOR.setHoverEvent(hoverEvent);

        MARKDOWN_VISITOR.parse(PARSER.parse(token.getActionText()));
        final BaseComponent[] baseComponent = MARKDOWN_VISITOR.build();
        if (baseComponent.length == 0) return;
        finalBuilder.append(baseComponent, ComponentBuilder.FormatRetention.NONE);
    }


    public BaseComponent[] build() {
        return finalBuilder.create();
    }

}
